// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_AnimationEvent;
struct C_AnimationEventDefaultTypeInternal;
extern C_AnimationEventDefaultTypeInternal _C_AnimationEvent_default_instance_;
class C_ChangeWaitingState;
struct C_ChangeWaitingStateDefaultTypeInternal;
extern C_ChangeWaitingStateDefaultTypeInternal _C_ChangeWaitingState_default_instance_;
class C_Chat;
struct C_ChatDefaultTypeInternal;
extern C_ChatDefaultTypeInternal _C_Chat_default_instance_;
class C_EnterGame;
struct C_EnterGameDefaultTypeInternal;
extern C_EnterGameDefaultTypeInternal _C_EnterGame_default_instance_;
class C_EnterGameFinish;
struct C_EnterGameFinishDefaultTypeInternal;
extern C_EnterGameFinishDefaultTypeInternal _C_EnterGameFinish_default_instance_;
class C_EnterLobby;
struct C_EnterLobbyDefaultTypeInternal;
extern C_EnterLobbyDefaultTypeInternal _C_EnterLobby_default_instance_;
class C_LeaveGame;
struct C_LeaveGameDefaultTypeInternal;
extern C_LeaveGameDefaultTypeInternal _C_LeaveGame_default_instance_;
class C_Login;
struct C_LoginDefaultTypeInternal;
extern C_LoginDefaultTypeInternal _C_Login_default_instance_;
class C_MakeRoom;
struct C_MakeRoomDefaultTypeInternal;
extern C_MakeRoomDefaultTypeInternal _C_MakeRoom_default_instance_;
class C_Move;
struct C_MoveDefaultTypeInternal;
extern C_MoveDefaultTypeInternal _C_Move_default_instance_;
class C_RequestAllRoomInfo;
struct C_RequestAllRoomInfoDefaultTypeInternal;
extern C_RequestAllRoomInfoDefaultTypeInternal _C_RequestAllRoomInfo_default_instance_;
class C_WaitingRoomEnter;
struct C_WaitingRoomEnterDefaultTypeInternal;
extern C_WaitingRoomEnterDefaultTypeInternal _C_WaitingRoomEnter_default_instance_;
class C_WaitingRoomOut;
struct C_WaitingRoomOutDefaultTypeInternal;
extern C_WaitingRoomOutDefaultTypeInternal _C_WaitingRoomOut_default_instance_;
class S_AnimationEvent;
struct S_AnimationEventDefaultTypeInternal;
extern S_AnimationEventDefaultTypeInternal _S_AnimationEvent_default_instance_;
class S_ChangeWaitingState;
struct S_ChangeWaitingStateDefaultTypeInternal;
extern S_ChangeWaitingStateDefaultTypeInternal _S_ChangeWaitingState_default_instance_;
class S_ChangeWaitingStateNotify;
struct S_ChangeWaitingStateNotifyDefaultTypeInternal;
extern S_ChangeWaitingStateNotifyDefaultTypeInternal _S_ChangeWaitingStateNotify_default_instance_;
class S_Chat;
struct S_ChatDefaultTypeInternal;
extern S_ChatDefaultTypeInternal _S_Chat_default_instance_;
class S_DeSpawn;
struct S_DeSpawnDefaultTypeInternal;
extern S_DeSpawnDefaultTypeInternal _S_DeSpawn_default_instance_;
class S_DestroyRoom;
struct S_DestroyRoomDefaultTypeInternal;
extern S_DestroyRoomDefaultTypeInternal _S_DestroyRoom_default_instance_;
class S_EnterGame;
struct S_EnterGameDefaultTypeInternal;
extern S_EnterGameDefaultTypeInternal _S_EnterGame_default_instance_;
class S_EnterGameFinish;
struct S_EnterGameFinishDefaultTypeInternal;
extern S_EnterGameFinishDefaultTypeInternal _S_EnterGameFinish_default_instance_;
class S_EnterLobby;
struct S_EnterLobbyDefaultTypeInternal;
extern S_EnterLobbyDefaultTypeInternal _S_EnterLobby_default_instance_;
class S_LeaveGame;
struct S_LeaveGameDefaultTypeInternal;
extern S_LeaveGameDefaultTypeInternal _S_LeaveGame_default_instance_;
class S_Login;
struct S_LoginDefaultTypeInternal;
extern S_LoginDefaultTypeInternal _S_Login_default_instance_;
class S_MakeRoom;
struct S_MakeRoomDefaultTypeInternal;
extern S_MakeRoomDefaultTypeInternal _S_MakeRoom_default_instance_;
class S_Move;
struct S_MoveDefaultTypeInternal;
extern S_MoveDefaultTypeInternal _S_Move_default_instance_;
class S_RequestAllRoomInfo;
struct S_RequestAllRoomInfoDefaultTypeInternal;
extern S_RequestAllRoomInfoDefaultTypeInternal _S_RequestAllRoomInfo_default_instance_;
class S_RequestRoomInfo;
struct S_RequestRoomInfoDefaultTypeInternal;
extern S_RequestRoomInfoDefaultTypeInternal _S_RequestRoomInfo_default_instance_;
class S_Spawn;
struct S_SpawnDefaultTypeInternal;
extern S_SpawnDefaultTypeInternal _S_Spawn_default_instance_;
class S_WaitingRoomEnter;
struct S_WaitingRoomEnterDefaultTypeInternal;
extern S_WaitingRoomEnterDefaultTypeInternal _S_WaitingRoomEnter_default_instance_;
class S_WaitingRoomEnterNotify;
struct S_WaitingRoomEnterNotifyDefaultTypeInternal;
extern S_WaitingRoomEnterNotifyDefaultTypeInternal _S_WaitingRoomEnterNotify_default_instance_;
class S_WaitingRoomOut;
struct S_WaitingRoomOutDefaultTypeInternal;
extern S_WaitingRoomOutDefaultTypeInternal _S_WaitingRoomOut_default_instance_;
class S_WaitingRoomOutNotify;
struct S_WaitingRoomOutNotifyDefaultTypeInternal;
extern S_WaitingRoomOutNotifyDefaultTypeInternal _S_WaitingRoomOutNotify_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_AnimationEvent* Arena::CreateMaybeMessage<::Protocol::C_AnimationEvent>(Arena*);
template<> ::Protocol::C_ChangeWaitingState* Arena::CreateMaybeMessage<::Protocol::C_ChangeWaitingState>(Arena*);
template<> ::Protocol::C_Chat* Arena::CreateMaybeMessage<::Protocol::C_Chat>(Arena*);
template<> ::Protocol::C_EnterGame* Arena::CreateMaybeMessage<::Protocol::C_EnterGame>(Arena*);
template<> ::Protocol::C_EnterGameFinish* Arena::CreateMaybeMessage<::Protocol::C_EnterGameFinish>(Arena*);
template<> ::Protocol::C_EnterLobby* Arena::CreateMaybeMessage<::Protocol::C_EnterLobby>(Arena*);
template<> ::Protocol::C_LeaveGame* Arena::CreateMaybeMessage<::Protocol::C_LeaveGame>(Arena*);
template<> ::Protocol::C_Login* Arena::CreateMaybeMessage<::Protocol::C_Login>(Arena*);
template<> ::Protocol::C_MakeRoom* Arena::CreateMaybeMessage<::Protocol::C_MakeRoom>(Arena*);
template<> ::Protocol::C_Move* Arena::CreateMaybeMessage<::Protocol::C_Move>(Arena*);
template<> ::Protocol::C_RequestAllRoomInfo* Arena::CreateMaybeMessage<::Protocol::C_RequestAllRoomInfo>(Arena*);
template<> ::Protocol::C_WaitingRoomEnter* Arena::CreateMaybeMessage<::Protocol::C_WaitingRoomEnter>(Arena*);
template<> ::Protocol::C_WaitingRoomOut* Arena::CreateMaybeMessage<::Protocol::C_WaitingRoomOut>(Arena*);
template<> ::Protocol::S_AnimationEvent* Arena::CreateMaybeMessage<::Protocol::S_AnimationEvent>(Arena*);
template<> ::Protocol::S_ChangeWaitingState* Arena::CreateMaybeMessage<::Protocol::S_ChangeWaitingState>(Arena*);
template<> ::Protocol::S_ChangeWaitingStateNotify* Arena::CreateMaybeMessage<::Protocol::S_ChangeWaitingStateNotify>(Arena*);
template<> ::Protocol::S_Chat* Arena::CreateMaybeMessage<::Protocol::S_Chat>(Arena*);
template<> ::Protocol::S_DeSpawn* Arena::CreateMaybeMessage<::Protocol::S_DeSpawn>(Arena*);
template<> ::Protocol::S_DestroyRoom* Arena::CreateMaybeMessage<::Protocol::S_DestroyRoom>(Arena*);
template<> ::Protocol::S_EnterGame* Arena::CreateMaybeMessage<::Protocol::S_EnterGame>(Arena*);
template<> ::Protocol::S_EnterGameFinish* Arena::CreateMaybeMessage<::Protocol::S_EnterGameFinish>(Arena*);
template<> ::Protocol::S_EnterLobby* Arena::CreateMaybeMessage<::Protocol::S_EnterLobby>(Arena*);
template<> ::Protocol::S_LeaveGame* Arena::CreateMaybeMessage<::Protocol::S_LeaveGame>(Arena*);
template<> ::Protocol::S_Login* Arena::CreateMaybeMessage<::Protocol::S_Login>(Arena*);
template<> ::Protocol::S_MakeRoom* Arena::CreateMaybeMessage<::Protocol::S_MakeRoom>(Arena*);
template<> ::Protocol::S_Move* Arena::CreateMaybeMessage<::Protocol::S_Move>(Arena*);
template<> ::Protocol::S_RequestAllRoomInfo* Arena::CreateMaybeMessage<::Protocol::S_RequestAllRoomInfo>(Arena*);
template<> ::Protocol::S_RequestRoomInfo* Arena::CreateMaybeMessage<::Protocol::S_RequestRoomInfo>(Arena*);
template<> ::Protocol::S_Spawn* Arena::CreateMaybeMessage<::Protocol::S_Spawn>(Arena*);
template<> ::Protocol::S_WaitingRoomEnter* Arena::CreateMaybeMessage<::Protocol::S_WaitingRoomEnter>(Arena*);
template<> ::Protocol::S_WaitingRoomEnterNotify* Arena::CreateMaybeMessage<::Protocol::S_WaitingRoomEnterNotify>(Arena*);
template<> ::Protocol::S_WaitingRoomOut* Arena::CreateMaybeMessage<::Protocol::S_WaitingRoomOut>(Arena*);
template<> ::Protocol::S_WaitingRoomOutNotify* Arena::CreateMaybeMessage<::Protocol::S_WaitingRoomOutNotify>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Login) */ {
 public:
  inline C_Login() : C_Login(nullptr) {}
  ~C_Login() override;
  explicit constexpr C_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Login(const C_Login& from);
  C_Login(C_Login&& from) noexcept
    : C_Login() {
    *this = ::std::move(from);
  }

  inline C_Login& operator=(const C_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Login& operator=(C_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Login* internal_default_instance() {
    return reinterpret_cast<const C_Login*>(
               &_C_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_Login& a, C_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Login* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_Login* New() const final {
    return new C_Login();
  }

  C_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_Login>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_Login& from);
  void MergeFrom(const C_Login& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Login* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Login";
  }
  protected:
  explicit C_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPwFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // int32 pw = 2;
  void clear_pw();
  ::PROTOBUF_NAMESPACE_ID::int32 pw() const;
  void set_pw(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pw() const;
  void _internal_set_pw(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::int32 pw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Login) */ {
 public:
  inline S_Login() : S_Login(nullptr) {}
  ~S_Login() override;
  explicit constexpr S_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Login(const S_Login& from);
  S_Login(S_Login&& from) noexcept
    : S_Login() {
    *this = ::std::move(from);
  }

  inline S_Login& operator=(const S_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Login& operator=(S_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Login* internal_default_instance() {
    return reinterpret_cast<const S_Login*>(
               &_S_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_Login& a, S_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Login* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Login* New() const final {
    return new S_Login();
  }

  S_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Login>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Login& from);
  void MergeFrom(const S_Login& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Login* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Login";
  }
  protected:
  explicit S_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EnterLobby final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EnterLobby) */ {
 public:
  inline C_EnterLobby() : C_EnterLobby(nullptr) {}
  ~C_EnterLobby() override;
  explicit constexpr C_EnterLobby(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EnterLobby(const C_EnterLobby& from);
  C_EnterLobby(C_EnterLobby&& from) noexcept
    : C_EnterLobby() {
    *this = ::std::move(from);
  }

  inline C_EnterLobby& operator=(const C_EnterLobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EnterLobby& operator=(C_EnterLobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EnterLobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EnterLobby* internal_default_instance() {
    return reinterpret_cast<const C_EnterLobby*>(
               &_C_EnterLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_EnterLobby& a, C_EnterLobby& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EnterLobby* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EnterLobby* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_EnterLobby* New() const final {
    return new C_EnterLobby();
  }

  C_EnterLobby* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_EnterLobby>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_EnterLobby& from);
  void MergeFrom(const C_EnterLobby& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EnterLobby* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EnterLobby";
  }
  protected:
  explicit C_EnterLobby(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_EnterLobby)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EnterLobby final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EnterLobby) */ {
 public:
  inline S_EnterLobby() : S_EnterLobby(nullptr) {}
  ~S_EnterLobby() override;
  explicit constexpr S_EnterLobby(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterLobby(const S_EnterLobby& from);
  S_EnterLobby(S_EnterLobby&& from) noexcept
    : S_EnterLobby() {
    *this = ::std::move(from);
  }

  inline S_EnterLobby& operator=(const S_EnterLobby& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterLobby& operator=(S_EnterLobby&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterLobby& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterLobby* internal_default_instance() {
    return reinterpret_cast<const S_EnterLobby*>(
               &_S_EnterLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_EnterLobby& a, S_EnterLobby& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterLobby* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterLobby* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_EnterLobby* New() const final {
    return new S_EnterLobby();
  }

  S_EnterLobby* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_EnterLobby>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_EnterLobby& from);
  void MergeFrom(const S_EnterLobby& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterLobby* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EnterLobby";
  }
  protected:
  explicit S_EnterLobby(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // uint64 playerId = 2;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EnterLobby)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_WaitingRoomEnter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_WaitingRoomEnter) */ {
 public:
  inline C_WaitingRoomEnter() : C_WaitingRoomEnter(nullptr) {}
  ~C_WaitingRoomEnter() override;
  explicit constexpr C_WaitingRoomEnter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_WaitingRoomEnter(const C_WaitingRoomEnter& from);
  C_WaitingRoomEnter(C_WaitingRoomEnter&& from) noexcept
    : C_WaitingRoomEnter() {
    *this = ::std::move(from);
  }

  inline C_WaitingRoomEnter& operator=(const C_WaitingRoomEnter& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_WaitingRoomEnter& operator=(C_WaitingRoomEnter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_WaitingRoomEnter& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_WaitingRoomEnter* internal_default_instance() {
    return reinterpret_cast<const C_WaitingRoomEnter*>(
               &_C_WaitingRoomEnter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_WaitingRoomEnter& a, C_WaitingRoomEnter& b) {
    a.Swap(&b);
  }
  inline void Swap(C_WaitingRoomEnter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_WaitingRoomEnter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_WaitingRoomEnter* New() const final {
    return new C_WaitingRoomEnter();
  }

  C_WaitingRoomEnter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_WaitingRoomEnter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_WaitingRoomEnter& from);
  void MergeFrom(const C_WaitingRoomEnter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_WaitingRoomEnter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_WaitingRoomEnter";
  }
  protected:
  explicit C_WaitingRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomInfoFieldNumber = 1,
  };
  // .Protocol.RoomInfo roomInfo = 1;
  bool has_roominfo() const;
  private:
  bool _internal_has_roominfo() const;
  public:
  void clear_roominfo();
  const ::Protocol::RoomInfo& roominfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::RoomInfo* release_roominfo();
  ::Protocol::RoomInfo* mutable_roominfo();
  void set_allocated_roominfo(::Protocol::RoomInfo* roominfo);
  private:
  const ::Protocol::RoomInfo& _internal_roominfo() const;
  ::Protocol::RoomInfo* _internal_mutable_roominfo();
  public:
  void unsafe_arena_set_allocated_roominfo(
      ::Protocol::RoomInfo* roominfo);
  ::Protocol::RoomInfo* unsafe_arena_release_roominfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_WaitingRoomEnter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::RoomInfo* roominfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_WaitingRoomEnter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_WaitingRoomEnter) */ {
 public:
  inline S_WaitingRoomEnter() : S_WaitingRoomEnter(nullptr) {}
  ~S_WaitingRoomEnter() override;
  explicit constexpr S_WaitingRoomEnter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_WaitingRoomEnter(const S_WaitingRoomEnter& from);
  S_WaitingRoomEnter(S_WaitingRoomEnter&& from) noexcept
    : S_WaitingRoomEnter() {
    *this = ::std::move(from);
  }

  inline S_WaitingRoomEnter& operator=(const S_WaitingRoomEnter& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_WaitingRoomEnter& operator=(S_WaitingRoomEnter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_WaitingRoomEnter& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_WaitingRoomEnter* internal_default_instance() {
    return reinterpret_cast<const S_WaitingRoomEnter*>(
               &_S_WaitingRoomEnter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_WaitingRoomEnter& a, S_WaitingRoomEnter& b) {
    a.Swap(&b);
  }
  inline void Swap(S_WaitingRoomEnter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_WaitingRoomEnter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_WaitingRoomEnter* New() const final {
    return new S_WaitingRoomEnter();
  }

  S_WaitingRoomEnter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_WaitingRoomEnter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_WaitingRoomEnter& from);
  void MergeFrom(const S_WaitingRoomEnter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_WaitingRoomEnter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_WaitingRoomEnter";
  }
  protected:
  explicit S_WaitingRoomEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomInfoFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .Protocol.RoomInfo roomInfo = 2;
  bool has_roominfo() const;
  private:
  bool _internal_has_roominfo() const;
  public:
  void clear_roominfo();
  const ::Protocol::RoomInfo& roominfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::RoomInfo* release_roominfo();
  ::Protocol::RoomInfo* mutable_roominfo();
  void set_allocated_roominfo(::Protocol::RoomInfo* roominfo);
  private:
  const ::Protocol::RoomInfo& _internal_roominfo() const;
  ::Protocol::RoomInfo* _internal_mutable_roominfo();
  public:
  void unsafe_arena_set_allocated_roominfo(
      ::Protocol::RoomInfo* roominfo);
  ::Protocol::RoomInfo* unsafe_arena_release_roominfo();

  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_WaitingRoomEnter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::RoomInfo* roominfo_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_WaitingRoomEnterNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_WaitingRoomEnterNotify) */ {
 public:
  inline S_WaitingRoomEnterNotify() : S_WaitingRoomEnterNotify(nullptr) {}
  ~S_WaitingRoomEnterNotify() override;
  explicit constexpr S_WaitingRoomEnterNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_WaitingRoomEnterNotify(const S_WaitingRoomEnterNotify& from);
  S_WaitingRoomEnterNotify(S_WaitingRoomEnterNotify&& from) noexcept
    : S_WaitingRoomEnterNotify() {
    *this = ::std::move(from);
  }

  inline S_WaitingRoomEnterNotify& operator=(const S_WaitingRoomEnterNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_WaitingRoomEnterNotify& operator=(S_WaitingRoomEnterNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_WaitingRoomEnterNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_WaitingRoomEnterNotify* internal_default_instance() {
    return reinterpret_cast<const S_WaitingRoomEnterNotify*>(
               &_S_WaitingRoomEnterNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_WaitingRoomEnterNotify& a, S_WaitingRoomEnterNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(S_WaitingRoomEnterNotify* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_WaitingRoomEnterNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_WaitingRoomEnterNotify* New() const final {
    return new S_WaitingRoomEnterNotify();
  }

  S_WaitingRoomEnterNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_WaitingRoomEnterNotify>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_WaitingRoomEnterNotify& from);
  void MergeFrom(const S_WaitingRoomEnterNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_WaitingRoomEnterNotify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_WaitingRoomEnterNotify";
  }
  protected:
  explicit S_WaitingRoomEnterNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Protocol.ObjectInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.S_WaitingRoomEnterNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* player_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MakeRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MakeRoom) */ {
 public:
  inline C_MakeRoom() : C_MakeRoom(nullptr) {}
  ~C_MakeRoom() override;
  explicit constexpr C_MakeRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MakeRoom(const C_MakeRoom& from);
  C_MakeRoom(C_MakeRoom&& from) noexcept
    : C_MakeRoom() {
    *this = ::std::move(from);
  }

  inline C_MakeRoom& operator=(const C_MakeRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MakeRoom& operator=(C_MakeRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MakeRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MakeRoom* internal_default_instance() {
    return reinterpret_cast<const C_MakeRoom*>(
               &_C_MakeRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C_MakeRoom& a, C_MakeRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MakeRoom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MakeRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_MakeRoom* New() const final {
    return new C_MakeRoom();
  }

  C_MakeRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_MakeRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_MakeRoom& from);
  void MergeFrom(const C_MakeRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MakeRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MakeRoom";
  }
  protected:
  explicit C_MakeRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomInfoFieldNumber = 1,
  };
  // .Protocol.RoomInfo roomInfo = 1;
  bool has_roominfo() const;
  private:
  bool _internal_has_roominfo() const;
  public:
  void clear_roominfo();
  const ::Protocol::RoomInfo& roominfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::RoomInfo* release_roominfo();
  ::Protocol::RoomInfo* mutable_roominfo();
  void set_allocated_roominfo(::Protocol::RoomInfo* roominfo);
  private:
  const ::Protocol::RoomInfo& _internal_roominfo() const;
  ::Protocol::RoomInfo* _internal_mutable_roominfo();
  public:
  void unsafe_arena_set_allocated_roominfo(
      ::Protocol::RoomInfo* roominfo);
  ::Protocol::RoomInfo* unsafe_arena_release_roominfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_MakeRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::RoomInfo* roominfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MakeRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MakeRoom) */ {
 public:
  inline S_MakeRoom() : S_MakeRoom(nullptr) {}
  ~S_MakeRoom() override;
  explicit constexpr S_MakeRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MakeRoom(const S_MakeRoom& from);
  S_MakeRoom(S_MakeRoom&& from) noexcept
    : S_MakeRoom() {
    *this = ::std::move(from);
  }

  inline S_MakeRoom& operator=(const S_MakeRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MakeRoom& operator=(S_MakeRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MakeRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MakeRoom* internal_default_instance() {
    return reinterpret_cast<const S_MakeRoom*>(
               &_S_MakeRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_MakeRoom& a, S_MakeRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MakeRoom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MakeRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_MakeRoom* New() const final {
    return new S_MakeRoom();
  }

  S_MakeRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_MakeRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_MakeRoom& from);
  void MergeFrom(const S_MakeRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MakeRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MakeRoom";
  }
  protected:
  explicit S_MakeRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMadeRoomInfoFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .Protocol.RoomInfo madeRoomInfo = 2;
  bool has_maderoominfo() const;
  private:
  bool _internal_has_maderoominfo() const;
  public:
  void clear_maderoominfo();
  const ::Protocol::RoomInfo& maderoominfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::RoomInfo* release_maderoominfo();
  ::Protocol::RoomInfo* mutable_maderoominfo();
  void set_allocated_maderoominfo(::Protocol::RoomInfo* maderoominfo);
  private:
  const ::Protocol::RoomInfo& _internal_maderoominfo() const;
  ::Protocol::RoomInfo* _internal_mutable_maderoominfo();
  public:
  void unsafe_arena_set_allocated_maderoominfo(
      ::Protocol::RoomInfo* maderoominfo);
  ::Protocol::RoomInfo* unsafe_arena_release_maderoominfo();

  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_MakeRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::RoomInfo* maderoominfo_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DestroyRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DestroyRoom) */ {
 public:
  inline S_DestroyRoom() : S_DestroyRoom(nullptr) {}
  ~S_DestroyRoom() override;
  explicit constexpr S_DestroyRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DestroyRoom(const S_DestroyRoom& from);
  S_DestroyRoom(S_DestroyRoom&& from) noexcept
    : S_DestroyRoom() {
    *this = ::std::move(from);
  }

  inline S_DestroyRoom& operator=(const S_DestroyRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DestroyRoom& operator=(S_DestroyRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DestroyRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DestroyRoom* internal_default_instance() {
    return reinterpret_cast<const S_DestroyRoom*>(
               &_S_DestroyRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_DestroyRoom& a, S_DestroyRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DestroyRoom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DestroyRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_DestroyRoom* New() const final {
    return new S_DestroyRoom();
  }

  S_DestroyRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_DestroyRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_DestroyRoom& from);
  void MergeFrom(const S_DestroyRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DestroyRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DestroyRoom";
  }
  protected:
  explicit S_DestroyRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomInfoFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .Protocol.RoomInfo roomInfo = 2;
  bool has_roominfo() const;
  private:
  bool _internal_has_roominfo() const;
  public:
  void clear_roominfo();
  const ::Protocol::RoomInfo& roominfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::RoomInfo* release_roominfo();
  ::Protocol::RoomInfo* mutable_roominfo();
  void set_allocated_roominfo(::Protocol::RoomInfo* roominfo);
  private:
  const ::Protocol::RoomInfo& _internal_roominfo() const;
  ::Protocol::RoomInfo* _internal_mutable_roominfo();
  public:
  void unsafe_arena_set_allocated_roominfo(
      ::Protocol::RoomInfo* roominfo);
  ::Protocol::RoomInfo* unsafe_arena_release_roominfo();

  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DestroyRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::RoomInfo* roominfo_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_RequestRoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_RequestRoomInfo) */ {
 public:
  inline S_RequestRoomInfo() : S_RequestRoomInfo(nullptr) {}
  ~S_RequestRoomInfo() override;
  explicit constexpr S_RequestRoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_RequestRoomInfo(const S_RequestRoomInfo& from);
  S_RequestRoomInfo(S_RequestRoomInfo&& from) noexcept
    : S_RequestRoomInfo() {
    *this = ::std::move(from);
  }

  inline S_RequestRoomInfo& operator=(const S_RequestRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_RequestRoomInfo& operator=(S_RequestRoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_RequestRoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_RequestRoomInfo* internal_default_instance() {
    return reinterpret_cast<const S_RequestRoomInfo*>(
               &_S_RequestRoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_RequestRoomInfo& a, S_RequestRoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(S_RequestRoomInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_RequestRoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_RequestRoomInfo* New() const final {
    return new S_RequestRoomInfo();
  }

  S_RequestRoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_RequestRoomInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_RequestRoomInfo& from);
  void MergeFrom(const S_RequestRoomInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_RequestRoomInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_RequestRoomInfo";
  }
  protected:
  explicit S_RequestRoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomInfoFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .Protocol.RoomInfo roomInfo = 2;
  bool has_roominfo() const;
  private:
  bool _internal_has_roominfo() const;
  public:
  void clear_roominfo();
  const ::Protocol::RoomInfo& roominfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::RoomInfo* release_roominfo();
  ::Protocol::RoomInfo* mutable_roominfo();
  void set_allocated_roominfo(::Protocol::RoomInfo* roominfo);
  private:
  const ::Protocol::RoomInfo& _internal_roominfo() const;
  ::Protocol::RoomInfo* _internal_mutable_roominfo();
  public:
  void unsafe_arena_set_allocated_roominfo(
      ::Protocol::RoomInfo* roominfo);
  ::Protocol::RoomInfo* unsafe_arena_release_roominfo();

  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_RequestRoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::RoomInfo* roominfo_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_RequestAllRoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_RequestAllRoomInfo) */ {
 public:
  inline C_RequestAllRoomInfo() : C_RequestAllRoomInfo(nullptr) {}
  ~C_RequestAllRoomInfo() override;
  explicit constexpr C_RequestAllRoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_RequestAllRoomInfo(const C_RequestAllRoomInfo& from);
  C_RequestAllRoomInfo(C_RequestAllRoomInfo&& from) noexcept
    : C_RequestAllRoomInfo() {
    *this = ::std::move(from);
  }

  inline C_RequestAllRoomInfo& operator=(const C_RequestAllRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_RequestAllRoomInfo& operator=(C_RequestAllRoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_RequestAllRoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_RequestAllRoomInfo* internal_default_instance() {
    return reinterpret_cast<const C_RequestAllRoomInfo*>(
               &_C_RequestAllRoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(C_RequestAllRoomInfo& a, C_RequestAllRoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(C_RequestAllRoomInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_RequestAllRoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_RequestAllRoomInfo* New() const final {
    return new C_RequestAllRoomInfo();
  }

  C_RequestAllRoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_RequestAllRoomInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_RequestAllRoomInfo& from);
  void MergeFrom(const C_RequestAllRoomInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_RequestAllRoomInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_RequestAllRoomInfo";
  }
  protected:
  explicit C_RequestAllRoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_RequestAllRoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_RequestAllRoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_RequestAllRoomInfo) */ {
 public:
  inline S_RequestAllRoomInfo() : S_RequestAllRoomInfo(nullptr) {}
  ~S_RequestAllRoomInfo() override;
  explicit constexpr S_RequestAllRoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_RequestAllRoomInfo(const S_RequestAllRoomInfo& from);
  S_RequestAllRoomInfo(S_RequestAllRoomInfo&& from) noexcept
    : S_RequestAllRoomInfo() {
    *this = ::std::move(from);
  }

  inline S_RequestAllRoomInfo& operator=(const S_RequestAllRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_RequestAllRoomInfo& operator=(S_RequestAllRoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_RequestAllRoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_RequestAllRoomInfo* internal_default_instance() {
    return reinterpret_cast<const S_RequestAllRoomInfo*>(
               &_S_RequestAllRoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_RequestAllRoomInfo& a, S_RequestAllRoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(S_RequestAllRoomInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_RequestAllRoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_RequestAllRoomInfo* New() const final {
    return new S_RequestAllRoomInfo();
  }

  S_RequestAllRoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_RequestAllRoomInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_RequestAllRoomInfo& from);
  void MergeFrom(const S_RequestAllRoomInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_RequestAllRoomInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_RequestAllRoomInfo";
  }
  protected:
  explicit S_RequestAllRoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomListFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .Protocol.RoomInfo roomList = 2;
  int roomlist_size() const;
  private:
  int _internal_roomlist_size() const;
  public:
  void clear_roomlist();
  ::Protocol::RoomInfo* mutable_roomlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
      mutable_roomlist();
  private:
  const ::Protocol::RoomInfo& _internal_roomlist(int index) const;
  ::Protocol::RoomInfo* _internal_add_roomlist();
  public:
  const ::Protocol::RoomInfo& roomlist(int index) const;
  ::Protocol::RoomInfo* add_roomlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
      roomlist() const;

  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_RequestAllRoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo > roomlist_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_WaitingRoomOut final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_WaitingRoomOut) */ {
 public:
  inline C_WaitingRoomOut() : C_WaitingRoomOut(nullptr) {}
  ~C_WaitingRoomOut() override;
  explicit constexpr C_WaitingRoomOut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_WaitingRoomOut(const C_WaitingRoomOut& from);
  C_WaitingRoomOut(C_WaitingRoomOut&& from) noexcept
    : C_WaitingRoomOut() {
    *this = ::std::move(from);
  }

  inline C_WaitingRoomOut& operator=(const C_WaitingRoomOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_WaitingRoomOut& operator=(C_WaitingRoomOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_WaitingRoomOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_WaitingRoomOut* internal_default_instance() {
    return reinterpret_cast<const C_WaitingRoomOut*>(
               &_C_WaitingRoomOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(C_WaitingRoomOut& a, C_WaitingRoomOut& b) {
    a.Swap(&b);
  }
  inline void Swap(C_WaitingRoomOut* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_WaitingRoomOut* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_WaitingRoomOut* New() const final {
    return new C_WaitingRoomOut();
  }

  C_WaitingRoomOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_WaitingRoomOut>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_WaitingRoomOut& from);
  void MergeFrom(const C_WaitingRoomOut& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_WaitingRoomOut* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_WaitingRoomOut";
  }
  protected:
  explicit C_WaitingRoomOut(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_WaitingRoomOut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_WaitingRoomOut final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_WaitingRoomOut) */ {
 public:
  inline S_WaitingRoomOut() : S_WaitingRoomOut(nullptr) {}
  ~S_WaitingRoomOut() override;
  explicit constexpr S_WaitingRoomOut(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_WaitingRoomOut(const S_WaitingRoomOut& from);
  S_WaitingRoomOut(S_WaitingRoomOut&& from) noexcept
    : S_WaitingRoomOut() {
    *this = ::std::move(from);
  }

  inline S_WaitingRoomOut& operator=(const S_WaitingRoomOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_WaitingRoomOut& operator=(S_WaitingRoomOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_WaitingRoomOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_WaitingRoomOut* internal_default_instance() {
    return reinterpret_cast<const S_WaitingRoomOut*>(
               &_S_WaitingRoomOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_WaitingRoomOut& a, S_WaitingRoomOut& b) {
    a.Swap(&b);
  }
  inline void Swap(S_WaitingRoomOut* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_WaitingRoomOut* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_WaitingRoomOut* New() const final {
    return new S_WaitingRoomOut();
  }

  S_WaitingRoomOut* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_WaitingRoomOut>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_WaitingRoomOut& from);
  void MergeFrom(const S_WaitingRoomOut& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_WaitingRoomOut* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_WaitingRoomOut";
  }
  protected:
  explicit S_WaitingRoomOut(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_WaitingRoomOut)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_WaitingRoomOutNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_WaitingRoomOutNotify) */ {
 public:
  inline S_WaitingRoomOutNotify() : S_WaitingRoomOutNotify(nullptr) {}
  ~S_WaitingRoomOutNotify() override;
  explicit constexpr S_WaitingRoomOutNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_WaitingRoomOutNotify(const S_WaitingRoomOutNotify& from);
  S_WaitingRoomOutNotify(S_WaitingRoomOutNotify&& from) noexcept
    : S_WaitingRoomOutNotify() {
    *this = ::std::move(from);
  }

  inline S_WaitingRoomOutNotify& operator=(const S_WaitingRoomOutNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_WaitingRoomOutNotify& operator=(S_WaitingRoomOutNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_WaitingRoomOutNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_WaitingRoomOutNotify* internal_default_instance() {
    return reinterpret_cast<const S_WaitingRoomOutNotify*>(
               &_S_WaitingRoomOutNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_WaitingRoomOutNotify& a, S_WaitingRoomOutNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(S_WaitingRoomOutNotify* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_WaitingRoomOutNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_WaitingRoomOutNotify* New() const final {
    return new S_WaitingRoomOutNotify();
  }

  S_WaitingRoomOutNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_WaitingRoomOutNotify>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_WaitingRoomOutNotify& from);
  void MergeFrom(const S_WaitingRoomOutNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_WaitingRoomOutNotify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_WaitingRoomOutNotify";
  }
  protected:
  explicit S_WaitingRoomOutNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Protocol.ObjectInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.S_WaitingRoomOutNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* player_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ChangeWaitingState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ChangeWaitingState) */ {
 public:
  inline C_ChangeWaitingState() : C_ChangeWaitingState(nullptr) {}
  ~C_ChangeWaitingState() override;
  explicit constexpr C_ChangeWaitingState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ChangeWaitingState(const C_ChangeWaitingState& from);
  C_ChangeWaitingState(C_ChangeWaitingState&& from) noexcept
    : C_ChangeWaitingState() {
    *this = ::std::move(from);
  }

  inline C_ChangeWaitingState& operator=(const C_ChangeWaitingState& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ChangeWaitingState& operator=(C_ChangeWaitingState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ChangeWaitingState& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ChangeWaitingState* internal_default_instance() {
    return reinterpret_cast<const C_ChangeWaitingState*>(
               &_C_ChangeWaitingState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(C_ChangeWaitingState& a, C_ChangeWaitingState& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ChangeWaitingState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ChangeWaitingState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_ChangeWaitingState* New() const final {
    return new C_ChangeWaitingState();
  }

  C_ChangeWaitingState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_ChangeWaitingState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_ChangeWaitingState& from);
  void MergeFrom(const C_ChangeWaitingState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ChangeWaitingState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ChangeWaitingState";
  }
  protected:
  explicit C_ChangeWaitingState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .Protocol.EWaitingState state = 1;
  void clear_state();
  ::Protocol::EWaitingState state() const;
  void set_state(::Protocol::EWaitingState value);
  private:
  ::Protocol::EWaitingState _internal_state() const;
  void _internal_set_state(::Protocol::EWaitingState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ChangeWaitingState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeWaitingState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ChangeWaitingState) */ {
 public:
  inline S_ChangeWaitingState() : S_ChangeWaitingState(nullptr) {}
  ~S_ChangeWaitingState() override;
  explicit constexpr S_ChangeWaitingState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeWaitingState(const S_ChangeWaitingState& from);
  S_ChangeWaitingState(S_ChangeWaitingState&& from) noexcept
    : S_ChangeWaitingState() {
    *this = ::std::move(from);
  }

  inline S_ChangeWaitingState& operator=(const S_ChangeWaitingState& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeWaitingState& operator=(S_ChangeWaitingState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeWaitingState& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeWaitingState* internal_default_instance() {
    return reinterpret_cast<const S_ChangeWaitingState*>(
               &_S_ChangeWaitingState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_ChangeWaitingState& a, S_ChangeWaitingState& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeWaitingState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeWaitingState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_ChangeWaitingState* New() const final {
    return new S_ChangeWaitingState();
  }

  S_ChangeWaitingState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_ChangeWaitingState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_ChangeWaitingState& from);
  void MergeFrom(const S_ChangeWaitingState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeWaitingState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ChangeWaitingState";
  }
  protected:
  explicit S_ChangeWaitingState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // .Protocol.EWaitingState state = 2;
  void clear_state();
  ::Protocol::EWaitingState state() const;
  void set_state(::Protocol::EWaitingState value);
  private:
  ::Protocol::EWaitingState _internal_state() const;
  void _internal_set_state(::Protocol::EWaitingState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ChangeWaitingState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int result_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeWaitingStateNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ChangeWaitingStateNotify) */ {
 public:
  inline S_ChangeWaitingStateNotify() : S_ChangeWaitingStateNotify(nullptr) {}
  ~S_ChangeWaitingStateNotify() override;
  explicit constexpr S_ChangeWaitingStateNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeWaitingStateNotify(const S_ChangeWaitingStateNotify& from);
  S_ChangeWaitingStateNotify(S_ChangeWaitingStateNotify&& from) noexcept
    : S_ChangeWaitingStateNotify() {
    *this = ::std::move(from);
  }

  inline S_ChangeWaitingStateNotify& operator=(const S_ChangeWaitingStateNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeWaitingStateNotify& operator=(S_ChangeWaitingStateNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeWaitingStateNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeWaitingStateNotify* internal_default_instance() {
    return reinterpret_cast<const S_ChangeWaitingStateNotify*>(
               &_S_ChangeWaitingStateNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_ChangeWaitingStateNotify& a, S_ChangeWaitingStateNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeWaitingStateNotify* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeWaitingStateNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_ChangeWaitingStateNotify* New() const final {
    return new S_ChangeWaitingStateNotify();
  }

  S_ChangeWaitingStateNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_ChangeWaitingStateNotify>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_ChangeWaitingStateNotify& from);
  void MergeFrom(const S_ChangeWaitingStateNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeWaitingStateNotify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ChangeWaitingStateNotify";
  }
  protected:
  explicit S_ChangeWaitingStateNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .Protocol.ObjectInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // .Protocol.EWaitingState state = 2;
  void clear_state();
  ::Protocol::EWaitingState state() const;
  void set_state(::Protocol::EWaitingState value);
  private:
  ::Protocol::EWaitingState _internal_state() const;
  void _internal_set_state(::Protocol::EWaitingState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ChangeWaitingStateNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* player_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EnterGame) */ {
 public:
  inline C_EnterGame() : C_EnterGame(nullptr) {}
  ~C_EnterGame() override;
  explicit constexpr C_EnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EnterGame(const C_EnterGame& from);
  C_EnterGame(C_EnterGame&& from) noexcept
    : C_EnterGame() {
    *this = ::std::move(from);
  }

  inline C_EnterGame& operator=(const C_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EnterGame& operator=(C_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EnterGame* internal_default_instance() {
    return reinterpret_cast<const C_EnterGame*>(
               &_C_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(C_EnterGame& a, C_EnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EnterGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_EnterGame* New() const final {
    return new C_EnterGame();
  }

  C_EnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_EnterGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_EnterGame& from);
  void MergeFrom(const C_EnterGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EnterGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EnterGame";
  }
  protected:
  explicit C_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_EnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EnterGame) */ {
 public:
  inline S_EnterGame() : S_EnterGame(nullptr) {}
  ~S_EnterGame() override;
  explicit constexpr S_EnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterGame(const S_EnterGame& from);
  S_EnterGame(S_EnterGame&& from) noexcept
    : S_EnterGame() {
    *this = ::std::move(from);
  }

  inline S_EnterGame& operator=(const S_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterGame& operator=(S_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterGame* internal_default_instance() {
    return reinterpret_cast<const S_EnterGame*>(
               &_S_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_EnterGame& a, S_EnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_EnterGame* New() const final {
    return new S_EnterGame();
  }

  S_EnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_EnterGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_EnterGame& from);
  void MergeFrom(const S_EnterGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EnterGame";
  }
  protected:
  explicit S_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .Protocol.ObjectInfo player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* player_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EnterGameFinish final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EnterGameFinish) */ {
 public:
  inline C_EnterGameFinish() : C_EnterGameFinish(nullptr) {}
  ~C_EnterGameFinish() override;
  explicit constexpr C_EnterGameFinish(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EnterGameFinish(const C_EnterGameFinish& from);
  C_EnterGameFinish(C_EnterGameFinish&& from) noexcept
    : C_EnterGameFinish() {
    *this = ::std::move(from);
  }

  inline C_EnterGameFinish& operator=(const C_EnterGameFinish& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EnterGameFinish& operator=(C_EnterGameFinish&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EnterGameFinish& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EnterGameFinish* internal_default_instance() {
    return reinterpret_cast<const C_EnterGameFinish*>(
               &_C_EnterGameFinish_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(C_EnterGameFinish& a, C_EnterGameFinish& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EnterGameFinish* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EnterGameFinish* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_EnterGameFinish* New() const final {
    return new C_EnterGameFinish();
  }

  C_EnterGameFinish* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_EnterGameFinish>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_EnterGameFinish& from);
  void MergeFrom(const C_EnterGameFinish& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EnterGameFinish* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EnterGameFinish";
  }
  protected:
  explicit C_EnterGameFinish(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_EnterGameFinish)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EnterGameFinish final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EnterGameFinish) */ {
 public:
  inline S_EnterGameFinish() : S_EnterGameFinish(nullptr) {}
  ~S_EnterGameFinish() override;
  explicit constexpr S_EnterGameFinish(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterGameFinish(const S_EnterGameFinish& from);
  S_EnterGameFinish(S_EnterGameFinish&& from) noexcept
    : S_EnterGameFinish() {
    *this = ::std::move(from);
  }

  inline S_EnterGameFinish& operator=(const S_EnterGameFinish& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterGameFinish& operator=(S_EnterGameFinish&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterGameFinish& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterGameFinish* internal_default_instance() {
    return reinterpret_cast<const S_EnterGameFinish*>(
               &_S_EnterGameFinish_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_EnterGameFinish& a, S_EnterGameFinish& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterGameFinish* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterGameFinish* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_EnterGameFinish* New() const final {
    return new S_EnterGameFinish();
  }

  S_EnterGameFinish* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_EnterGameFinish>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_EnterGameFinish& from);
  void MergeFrom(const S_EnterGameFinish& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterGameFinish* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EnterGameFinish";
  }
  protected:
  explicit S_EnterGameFinish(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EnterGameFinish)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LeaveGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LeaveGame) */ {
 public:
  inline C_LeaveGame() : C_LeaveGame(nullptr) {}
  ~C_LeaveGame() override;
  explicit constexpr C_LeaveGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LeaveGame(const C_LeaveGame& from);
  C_LeaveGame(C_LeaveGame&& from) noexcept
    : C_LeaveGame() {
    *this = ::std::move(from);
  }

  inline C_LeaveGame& operator=(const C_LeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LeaveGame& operator=(C_LeaveGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LeaveGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LeaveGame* internal_default_instance() {
    return reinterpret_cast<const C_LeaveGame*>(
               &_C_LeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(C_LeaveGame& a, C_LeaveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LeaveGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LeaveGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_LeaveGame* New() const final {
    return new C_LeaveGame();
  }

  C_LeaveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_LeaveGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_LeaveGame& from);
  void MergeFrom(const C_LeaveGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LeaveGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LeaveGame";
  }
  protected:
  explicit C_LeaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LeaveGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LeaveGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LeaveGame) */ {
 public:
  inline S_LeaveGame() : S_LeaveGame(nullptr) {}
  ~S_LeaveGame() override;
  explicit constexpr S_LeaveGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LeaveGame(const S_LeaveGame& from);
  S_LeaveGame(S_LeaveGame&& from) noexcept
    : S_LeaveGame() {
    *this = ::std::move(from);
  }

  inline S_LeaveGame& operator=(const S_LeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LeaveGame& operator=(S_LeaveGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LeaveGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LeaveGame* internal_default_instance() {
    return reinterpret_cast<const S_LeaveGame*>(
               &_S_LeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_LeaveGame& a, S_LeaveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LeaveGame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LeaveGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_LeaveGame* New() const final {
    return new S_LeaveGame();
  }

  S_LeaveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_LeaveGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_LeaveGame& from);
  void MergeFrom(const S_LeaveGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LeaveGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LeaveGame";
  }
  protected:
  explicit S_LeaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_LeaveGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Move) */ {
 public:
  inline C_Move() : C_Move(nullptr) {}
  ~C_Move() override;
  explicit constexpr C_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Move(const C_Move& from);
  C_Move(C_Move&& from) noexcept
    : C_Move() {
    *this = ::std::move(from);
  }

  inline C_Move& operator=(const C_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Move& operator=(C_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Move* internal_default_instance() {
    return reinterpret_cast<const C_Move*>(
               &_C_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(C_Move& a, C_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Move* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_Move* New() const final {
    return new C_Move();
  }

  C_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_Move>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_Move& from);
  void MergeFrom(const C_Move& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Move* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Move";
  }
  protected:
  explicit C_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo objectInfo = 1;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Move) */ {
 public:
  inline S_Move() : S_Move(nullptr) {}
  ~S_Move() override;
  explicit constexpr S_Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Move(const S_Move& from);
  S_Move(S_Move&& from) noexcept
    : S_Move() {
    *this = ::std::move(from);
  }

  inline S_Move& operator=(const S_Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Move& operator=(S_Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Move* internal_default_instance() {
    return reinterpret_cast<const S_Move*>(
               &_S_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(S_Move& a, S_Move& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Move* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Move* New() const final {
    return new S_Move();
  }

  S_Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Move>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Move& from);
  void MergeFrom(const S_Move& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Move* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Move";
  }
  protected:
  explicit S_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectInfoFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .Protocol.ObjectInfo objectInfo = 2;
  bool has_objectinfo() const;
  private:
  bool _internal_has_objectinfo() const;
  public:
  void clear_objectinfo();
  const ::Protocol::ObjectInfo& objectinfo() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::Protocol::ObjectInfo* release_objectinfo();
  ::Protocol::ObjectInfo* mutable_objectinfo();
  void set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo);
  private:
  const ::Protocol::ObjectInfo& _internal_objectinfo() const;
  ::Protocol::ObjectInfo* _internal_mutable_objectinfo();
  public:
  void unsafe_arena_set_allocated_objectinfo(
      ::Protocol::ObjectInfo* objectinfo);
  ::Protocol::ObjectInfo* unsafe_arena_release_objectinfo();

  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::ObjectInfo* objectinfo_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Spawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Spawn) */ {
 public:
  inline S_Spawn() : S_Spawn(nullptr) {}
  ~S_Spawn() override;
  explicit constexpr S_Spawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Spawn(const S_Spawn& from);
  S_Spawn(S_Spawn&& from) noexcept
    : S_Spawn() {
    *this = ::std::move(from);
  }

  inline S_Spawn& operator=(const S_Spawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Spawn& operator=(S_Spawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Spawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Spawn* internal_default_instance() {
    return reinterpret_cast<const S_Spawn*>(
               &_S_Spawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_Spawn& a, S_Spawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Spawn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Spawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Spawn* New() const final {
    return new S_Spawn();
  }

  S_Spawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Spawn>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Spawn& from);
  void MergeFrom(const S_Spawn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Spawn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Spawn";
  }
  protected:
  explicit S_Spawn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectListFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .Protocol.ObjectInfo objectList = 2;
  int objectlist_size() const;
  private:
  int _internal_objectlist_size() const;
  public:
  void clear_objectlist();
  ::Protocol::ObjectInfo* mutable_objectlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_objectlist();
  private:
  const ::Protocol::ObjectInfo& _internal_objectlist(int index) const;
  ::Protocol::ObjectInfo* _internal_add_objectlist();
  public:
  const ::Protocol::ObjectInfo& objectlist(int index) const;
  ::Protocol::ObjectInfo* add_objectlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      objectlist() const;

  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Spawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > objectlist_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DeSpawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DeSpawn) */ {
 public:
  inline S_DeSpawn() : S_DeSpawn(nullptr) {}
  ~S_DeSpawn() override;
  explicit constexpr S_DeSpawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DeSpawn(const S_DeSpawn& from);
  S_DeSpawn(S_DeSpawn&& from) noexcept
    : S_DeSpawn() {
    *this = ::std::move(from);
  }

  inline S_DeSpawn& operator=(const S_DeSpawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DeSpawn& operator=(S_DeSpawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DeSpawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DeSpawn* internal_default_instance() {
    return reinterpret_cast<const S_DeSpawn*>(
               &_S_DeSpawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(S_DeSpawn& a, S_DeSpawn& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DeSpawn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DeSpawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_DeSpawn* New() const final {
    return new S_DeSpawn();
  }

  S_DeSpawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_DeSpawn>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_DeSpawn& from);
  void MergeFrom(const S_DeSpawn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DeSpawn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DeSpawn";
  }
  protected:
  explicit S_DeSpawn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated uint64 ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_ids() const;
  void _internal_add_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 ids(int index) const;
  void set_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_ids();

  // @@protoc_insertion_point(class_scope:Protocol.S_DeSpawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > ids_;
  mutable std::atomic<int> _ids_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_Chat) */ {
 public:
  inline C_Chat() : C_Chat(nullptr) {}
  ~C_Chat() override;
  explicit constexpr C_Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_Chat(const C_Chat& from);
  C_Chat(C_Chat&& from) noexcept
    : C_Chat() {
    *this = ::std::move(from);
  }

  inline C_Chat& operator=(const C_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_Chat& operator=(C_Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_Chat* internal_default_instance() {
    return reinterpret_cast<const C_Chat*>(
               &_C_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(C_Chat& a, C_Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(C_Chat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_Chat* New() const final {
    return new C_Chat();
  }

  C_Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_Chat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_Chat& from);
  void MergeFrom(const C_Chat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_Chat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_Chat";
  }
  protected:
  explicit C_Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_Chat) */ {
 public:
  inline S_Chat() : S_Chat(nullptr) {}
  ~S_Chat() override;
  explicit constexpr S_Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Chat(const S_Chat& from);
  S_Chat(S_Chat&& from) noexcept
    : S_Chat() {
    *this = ::std::move(from);
  }

  inline S_Chat& operator=(const S_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Chat& operator=(S_Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Chat* internal_default_instance() {
    return reinterpret_cast<const S_Chat*>(
               &_S_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(S_Chat& a, S_Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Chat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_Chat* New() const final {
    return new S_Chat();
  }

  S_Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_Chat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_Chat& from);
  void MergeFrom(const S_Chat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Chat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_Chat";
  }
  protected:
  explicit S_Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint64 playerId = 1;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_AnimationEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_AnimationEvent) */ {
 public:
  inline C_AnimationEvent() : C_AnimationEvent(nullptr) {}
  ~C_AnimationEvent() override;
  explicit constexpr C_AnimationEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AnimationEvent(const C_AnimationEvent& from);
  C_AnimationEvent(C_AnimationEvent&& from) noexcept
    : C_AnimationEvent() {
    *this = ::std::move(from);
  }

  inline C_AnimationEvent& operator=(const C_AnimationEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AnimationEvent& operator=(C_AnimationEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AnimationEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AnimationEvent* internal_default_instance() {
    return reinterpret_cast<const C_AnimationEvent*>(
               &_C_AnimationEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(C_AnimationEvent& a, C_AnimationEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AnimationEvent* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AnimationEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C_AnimationEvent* New() const final {
    return new C_AnimationEvent();
  }

  C_AnimationEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C_AnimationEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const C_AnimationEvent& from);
  void MergeFrom(const C_AnimationEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AnimationEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_AnimationEvent";
  }
  protected:
  explicit C_AnimationEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimationTypeFieldNumber = 1,
    kParamTypeFieldNumber = 2,
    kBoolValueFieldNumber = 3,
    kFloatValueFieldNumber = 4,
  };
  // string animationType = 1;
  void clear_animationtype();
  const std::string& animationtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_animationtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_animationtype();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_animationtype();
  void set_allocated_animationtype(std::string* animationtype);
  private:
  const std::string& _internal_animationtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_animationtype(const std::string& value);
  std::string* _internal_mutable_animationtype();
  public:

  // .Protocol.EAnimationParamType paramType = 2;
  void clear_paramtype();
  ::Protocol::EAnimationParamType paramtype() const;
  void set_paramtype(::Protocol::EAnimationParamType value);
  private:
  ::Protocol::EAnimationParamType _internal_paramtype() const;
  void _internal_set_paramtype(::Protocol::EAnimationParamType value);
  public:

  // bool boolValue = 3;
  void clear_boolvalue();
  bool boolvalue() const;
  void set_boolvalue(bool value);
  private:
  bool _internal_boolvalue() const;
  void _internal_set_boolvalue(bool value);
  public:

  // float floatValue = 4;
  void clear_floatvalue();
  float floatvalue() const;
  void set_floatvalue(float value);
  private:
  float _internal_floatvalue() const;
  void _internal_set_floatvalue(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_AnimationEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr animationtype_;
  int paramtype_;
  bool boolvalue_;
  float floatvalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_AnimationEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_AnimationEvent) */ {
 public:
  inline S_AnimationEvent() : S_AnimationEvent(nullptr) {}
  ~S_AnimationEvent() override;
  explicit constexpr S_AnimationEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AnimationEvent(const S_AnimationEvent& from);
  S_AnimationEvent(S_AnimationEvent&& from) noexcept
    : S_AnimationEvent() {
    *this = ::std::move(from);
  }

  inline S_AnimationEvent& operator=(const S_AnimationEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AnimationEvent& operator=(S_AnimationEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AnimationEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AnimationEvent* internal_default_instance() {
    return reinterpret_cast<const S_AnimationEvent*>(
               &_S_AnimationEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(S_AnimationEvent& a, S_AnimationEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AnimationEvent* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AnimationEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S_AnimationEvent* New() const final {
    return new S_AnimationEvent();
  }

  S_AnimationEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S_AnimationEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const S_AnimationEvent& from);
  void MergeFrom(const S_AnimationEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AnimationEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_AnimationEvent";
  }
  protected:
  explicit S_AnimationEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimationTypeFieldNumber = 3,
    kPlayerIdFieldNumber = 2,
    kResultFieldNumber = 1,
    kParamTypeFieldNumber = 4,
    kBoolValueFieldNumber = 5,
    kFloatValueFieldNumber = 6,
  };
  // string animationType = 3;
  void clear_animationtype();
  const std::string& animationtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_animationtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_animationtype();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_animationtype();
  void set_allocated_animationtype(std::string* animationtype);
  private:
  const std::string& _internal_animationtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_animationtype(const std::string& value);
  std::string* _internal_mutable_animationtype();
  public:

  // uint64 playerId = 2;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .Protocol.EResultCode result = 1;
  void clear_result();
  ::Protocol::EResultCode result() const;
  void set_result(::Protocol::EResultCode value);
  private:
  ::Protocol::EResultCode _internal_result() const;
  void _internal_set_result(::Protocol::EResultCode value);
  public:

  // .Protocol.EAnimationParamType paramType = 4;
  void clear_paramtype();
  ::Protocol::EAnimationParamType paramtype() const;
  void set_paramtype(::Protocol::EAnimationParamType value);
  private:
  ::Protocol::EAnimationParamType _internal_paramtype() const;
  void _internal_set_paramtype(::Protocol::EAnimationParamType value);
  public:

  // bool boolValue = 5;
  void clear_boolvalue();
  bool boolvalue() const;
  void set_boolvalue(bool value);
  private:
  bool _internal_boolvalue() const;
  void _internal_set_boolvalue(bool value);
  public:

  // float floatValue = 6;
  void clear_floatvalue();
  float floatvalue() const;
  void set_floatvalue(float value);
  private:
  float _internal_floatvalue() const;
  void _internal_set_floatvalue(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_AnimationEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr animationtype_;
  ::PROTOBUF_NAMESPACE_ID::uint64 playerid_;
  int result_;
  int paramtype_;
  bool boolvalue_;
  float floatvalue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_Login

// string id = 1;
inline void C_Login::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& C_Login::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Login.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Login::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_Login.id)
}
inline std::string* C_Login::mutable_id() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_Login.id)
  return _internal_mutable_id();
}
inline const std::string& C_Login::_internal_id() const {
  return id_.Get();
}
inline void C_Login::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_Login::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_Login::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.C_Login.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_Login::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Login.id)
}

// int32 pw = 2;
inline void C_Login::clear_pw() {
  pw_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 C_Login::_internal_pw() const {
  return pw_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 C_Login::pw() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Login.pw)
  return _internal_pw();
}
inline void C_Login::_internal_set_pw(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pw_ = value;
}
inline void C_Login::set_pw(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pw(value);
  // @@protoc_insertion_point(field_set:Protocol.C_Login.pw)
}

// -------------------------------------------------------------------

// S_Login

// bool success = 1;
inline void S_Login::clear_success() {
  success_ = false;
}
inline bool S_Login::_internal_success() const {
  return success_;
}
inline bool S_Login::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Login.success)
  return _internal_success();
}
inline void S_Login::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_Login::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Login.success)
}

// -------------------------------------------------------------------

// C_EnterLobby

// -------------------------------------------------------------------

// S_EnterLobby

// bool success = 1;
inline void S_EnterLobby::clear_success() {
  success_ = false;
}
inline bool S_EnterLobby::_internal_success() const {
  return success_;
}
inline bool S_EnterLobby::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterLobby.success)
  return _internal_success();
}
inline void S_EnterLobby::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void S_EnterLobby::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EnterLobby.success)
}

// uint64 playerId = 2;
inline void S_EnterLobby::clear_playerid() {
  playerid_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_EnterLobby::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_EnterLobby::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterLobby.playerId)
  return _internal_playerid();
}
inline void S_EnterLobby::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  playerid_ = value;
}
inline void S_EnterLobby::set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EnterLobby.playerId)
}

// -------------------------------------------------------------------

// C_WaitingRoomEnter

// .Protocol.RoomInfo roomInfo = 1;
inline bool C_WaitingRoomEnter::_internal_has_roominfo() const {
  return this != internal_default_instance() && roominfo_ != nullptr;
}
inline bool C_WaitingRoomEnter::has_roominfo() const {
  return _internal_has_roominfo();
}
inline const ::Protocol::RoomInfo& C_WaitingRoomEnter::_internal_roominfo() const {
  const ::Protocol::RoomInfo* p = roominfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& C_WaitingRoomEnter::roominfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_WaitingRoomEnter.roomInfo)
  return _internal_roominfo();
}
inline void C_WaitingRoomEnter::unsafe_arena_set_allocated_roominfo(
    ::Protocol::RoomInfo* roominfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  roominfo_ = roominfo;
  if (roominfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_WaitingRoomEnter.roomInfo)
}
inline ::Protocol::RoomInfo* C_WaitingRoomEnter::release_roominfo() {
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::RoomInfo* C_WaitingRoomEnter::unsafe_arena_release_roominfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_WaitingRoomEnter.roomInfo)
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* C_WaitingRoomEnter::_internal_mutable_roominfo() {
  
  if (roominfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    roominfo_ = p;
  }
  return roominfo_;
}
inline ::Protocol::RoomInfo* C_WaitingRoomEnter::mutable_roominfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_WaitingRoomEnter.roomInfo)
  return _internal_mutable_roominfo();
}
inline void C_WaitingRoomEnter::set_allocated_roominfo(::Protocol::RoomInfo* roominfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  if (roominfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo));
    if (message_arena != submessage_arena) {
      roominfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roominfo, submessage_arena);
    }
    
  } else {
    
  }
  roominfo_ = roominfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_WaitingRoomEnter.roomInfo)
}

// -------------------------------------------------------------------

// S_WaitingRoomEnter

// .Protocol.EResultCode result = 1;
inline void S_WaitingRoomEnter::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_WaitingRoomEnter::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_WaitingRoomEnter::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_WaitingRoomEnter.result)
  return _internal_result();
}
inline void S_WaitingRoomEnter::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_WaitingRoomEnter::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_WaitingRoomEnter.result)
}

// .Protocol.RoomInfo roomInfo = 2;
inline bool S_WaitingRoomEnter::_internal_has_roominfo() const {
  return this != internal_default_instance() && roominfo_ != nullptr;
}
inline bool S_WaitingRoomEnter::has_roominfo() const {
  return _internal_has_roominfo();
}
inline const ::Protocol::RoomInfo& S_WaitingRoomEnter::_internal_roominfo() const {
  const ::Protocol::RoomInfo* p = roominfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& S_WaitingRoomEnter::roominfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_WaitingRoomEnter.roomInfo)
  return _internal_roominfo();
}
inline void S_WaitingRoomEnter::unsafe_arena_set_allocated_roominfo(
    ::Protocol::RoomInfo* roominfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  roominfo_ = roominfo;
  if (roominfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_WaitingRoomEnter.roomInfo)
}
inline ::Protocol::RoomInfo* S_WaitingRoomEnter::release_roominfo() {
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::RoomInfo* S_WaitingRoomEnter::unsafe_arena_release_roominfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_WaitingRoomEnter.roomInfo)
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* S_WaitingRoomEnter::_internal_mutable_roominfo() {
  
  if (roominfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    roominfo_ = p;
  }
  return roominfo_;
}
inline ::Protocol::RoomInfo* S_WaitingRoomEnter::mutable_roominfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_WaitingRoomEnter.roomInfo)
  return _internal_mutable_roominfo();
}
inline void S_WaitingRoomEnter::set_allocated_roominfo(::Protocol::RoomInfo* roominfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  if (roominfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo));
    if (message_arena != submessage_arena) {
      roominfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roominfo, submessage_arena);
    }
    
  } else {
    
  }
  roominfo_ = roominfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_WaitingRoomEnter.roomInfo)
}

// -------------------------------------------------------------------

// S_WaitingRoomEnterNotify

// .Protocol.ObjectInfo player = 1;
inline bool S_WaitingRoomEnterNotify::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool S_WaitingRoomEnterNotify::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& S_WaitingRoomEnterNotify::_internal_player() const {
  const ::Protocol::ObjectInfo* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_WaitingRoomEnterNotify::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_WaitingRoomEnterNotify.player)
  return _internal_player();
}
inline void S_WaitingRoomEnterNotify::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_WaitingRoomEnterNotify.player)
}
inline ::Protocol::ObjectInfo* S_WaitingRoomEnterNotify::release_player() {
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_WaitingRoomEnterNotify::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_WaitingRoomEnterNotify.player)
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_WaitingRoomEnterNotify::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::Protocol::ObjectInfo* S_WaitingRoomEnterNotify::mutable_player() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_WaitingRoomEnterNotify.player)
  return _internal_mutable_player();
}
inline void S_WaitingRoomEnterNotify::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_WaitingRoomEnterNotify.player)
}

// -------------------------------------------------------------------

// C_MakeRoom

// .Protocol.RoomInfo roomInfo = 1;
inline bool C_MakeRoom::_internal_has_roominfo() const {
  return this != internal_default_instance() && roominfo_ != nullptr;
}
inline bool C_MakeRoom::has_roominfo() const {
  return _internal_has_roominfo();
}
inline const ::Protocol::RoomInfo& C_MakeRoom::_internal_roominfo() const {
  const ::Protocol::RoomInfo* p = roominfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& C_MakeRoom::roominfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MakeRoom.roomInfo)
  return _internal_roominfo();
}
inline void C_MakeRoom::unsafe_arena_set_allocated_roominfo(
    ::Protocol::RoomInfo* roominfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  roominfo_ = roominfo;
  if (roominfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MakeRoom.roomInfo)
}
inline ::Protocol::RoomInfo* C_MakeRoom::release_roominfo() {
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::RoomInfo* C_MakeRoom::unsafe_arena_release_roominfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_MakeRoom.roomInfo)
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* C_MakeRoom::_internal_mutable_roominfo() {
  
  if (roominfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    roominfo_ = p;
  }
  return roominfo_;
}
inline ::Protocol::RoomInfo* C_MakeRoom::mutable_roominfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_MakeRoom.roomInfo)
  return _internal_mutable_roominfo();
}
inline void C_MakeRoom::set_allocated_roominfo(::Protocol::RoomInfo* roominfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  if (roominfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo));
    if (message_arena != submessage_arena) {
      roominfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roominfo, submessage_arena);
    }
    
  } else {
    
  }
  roominfo_ = roominfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MakeRoom.roomInfo)
}

// -------------------------------------------------------------------

// S_MakeRoom

// .Protocol.EResultCode result = 1;
inline void S_MakeRoom::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_MakeRoom::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_MakeRoom::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MakeRoom.result)
  return _internal_result();
}
inline void S_MakeRoom::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_MakeRoom::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MakeRoom.result)
}

// .Protocol.RoomInfo madeRoomInfo = 2;
inline bool S_MakeRoom::_internal_has_maderoominfo() const {
  return this != internal_default_instance() && maderoominfo_ != nullptr;
}
inline bool S_MakeRoom::has_maderoominfo() const {
  return _internal_has_maderoominfo();
}
inline const ::Protocol::RoomInfo& S_MakeRoom::_internal_maderoominfo() const {
  const ::Protocol::RoomInfo* p = maderoominfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& S_MakeRoom::maderoominfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MakeRoom.madeRoomInfo)
  return _internal_maderoominfo();
}
inline void S_MakeRoom::unsafe_arena_set_allocated_maderoominfo(
    ::Protocol::RoomInfo* maderoominfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maderoominfo_);
  }
  maderoominfo_ = maderoominfo;
  if (maderoominfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MakeRoom.madeRoomInfo)
}
inline ::Protocol::RoomInfo* S_MakeRoom::release_maderoominfo() {
  
  ::Protocol::RoomInfo* temp = maderoominfo_;
  maderoominfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::RoomInfo* S_MakeRoom::unsafe_arena_release_maderoominfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_MakeRoom.madeRoomInfo)
  
  ::Protocol::RoomInfo* temp = maderoominfo_;
  maderoominfo_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* S_MakeRoom::_internal_mutable_maderoominfo() {
  
  if (maderoominfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    maderoominfo_ = p;
  }
  return maderoominfo_;
}
inline ::Protocol::RoomInfo* S_MakeRoom::mutable_maderoominfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_MakeRoom.madeRoomInfo)
  return _internal_mutable_maderoominfo();
}
inline void S_MakeRoom::set_allocated_maderoominfo(::Protocol::RoomInfo* maderoominfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(maderoominfo_);
  }
  if (maderoominfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maderoominfo));
    if (message_arena != submessage_arena) {
      maderoominfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maderoominfo, submessage_arena);
    }
    
  } else {
    
  }
  maderoominfo_ = maderoominfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MakeRoom.madeRoomInfo)
}

// -------------------------------------------------------------------

// S_DestroyRoom

// .Protocol.EResultCode result = 1;
inline void S_DestroyRoom::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_DestroyRoom::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_DestroyRoom::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DestroyRoom.result)
  return _internal_result();
}
inline void S_DestroyRoom::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_DestroyRoom::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DestroyRoom.result)
}

// .Protocol.RoomInfo roomInfo = 2;
inline bool S_DestroyRoom::_internal_has_roominfo() const {
  return this != internal_default_instance() && roominfo_ != nullptr;
}
inline bool S_DestroyRoom::has_roominfo() const {
  return _internal_has_roominfo();
}
inline const ::Protocol::RoomInfo& S_DestroyRoom::_internal_roominfo() const {
  const ::Protocol::RoomInfo* p = roominfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& S_DestroyRoom::roominfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DestroyRoom.roomInfo)
  return _internal_roominfo();
}
inline void S_DestroyRoom::unsafe_arena_set_allocated_roominfo(
    ::Protocol::RoomInfo* roominfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  roominfo_ = roominfo;
  if (roominfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_DestroyRoom.roomInfo)
}
inline ::Protocol::RoomInfo* S_DestroyRoom::release_roominfo() {
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::RoomInfo* S_DestroyRoom::unsafe_arena_release_roominfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_DestroyRoom.roomInfo)
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* S_DestroyRoom::_internal_mutable_roominfo() {
  
  if (roominfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    roominfo_ = p;
  }
  return roominfo_;
}
inline ::Protocol::RoomInfo* S_DestroyRoom::mutable_roominfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_DestroyRoom.roomInfo)
  return _internal_mutable_roominfo();
}
inline void S_DestroyRoom::set_allocated_roominfo(::Protocol::RoomInfo* roominfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  if (roominfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo));
    if (message_arena != submessage_arena) {
      roominfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roominfo, submessage_arena);
    }
    
  } else {
    
  }
  roominfo_ = roominfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_DestroyRoom.roomInfo)
}

// -------------------------------------------------------------------

// S_RequestRoomInfo

// .Protocol.EResultCode result = 1;
inline void S_RequestRoomInfo::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_RequestRoomInfo::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_RequestRoomInfo::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_RequestRoomInfo.result)
  return _internal_result();
}
inline void S_RequestRoomInfo::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_RequestRoomInfo::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_RequestRoomInfo.result)
}

// .Protocol.RoomInfo roomInfo = 2;
inline bool S_RequestRoomInfo::_internal_has_roominfo() const {
  return this != internal_default_instance() && roominfo_ != nullptr;
}
inline bool S_RequestRoomInfo::has_roominfo() const {
  return _internal_has_roominfo();
}
inline const ::Protocol::RoomInfo& S_RequestRoomInfo::_internal_roominfo() const {
  const ::Protocol::RoomInfo* p = roominfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& S_RequestRoomInfo::roominfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_RequestRoomInfo.roomInfo)
  return _internal_roominfo();
}
inline void S_RequestRoomInfo::unsafe_arena_set_allocated_roominfo(
    ::Protocol::RoomInfo* roominfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  roominfo_ = roominfo;
  if (roominfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_RequestRoomInfo.roomInfo)
}
inline ::Protocol::RoomInfo* S_RequestRoomInfo::release_roominfo() {
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::RoomInfo* S_RequestRoomInfo::unsafe_arena_release_roominfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_RequestRoomInfo.roomInfo)
  
  ::Protocol::RoomInfo* temp = roominfo_;
  roominfo_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* S_RequestRoomInfo::_internal_mutable_roominfo() {
  
  if (roominfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    roominfo_ = p;
  }
  return roominfo_;
}
inline ::Protocol::RoomInfo* S_RequestRoomInfo::mutable_roominfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_RequestRoomInfo.roomInfo)
  return _internal_mutable_roominfo();
}
inline void S_RequestRoomInfo::set_allocated_roominfo(::Protocol::RoomInfo* roominfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo_);
  }
  if (roominfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo));
    if (message_arena != submessage_arena) {
      roominfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roominfo, submessage_arena);
    }
    
  } else {
    
  }
  roominfo_ = roominfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_RequestRoomInfo.roomInfo)
}

// -------------------------------------------------------------------

// C_RequestAllRoomInfo

// -------------------------------------------------------------------

// S_RequestAllRoomInfo

// .Protocol.EResultCode result = 1;
inline void S_RequestAllRoomInfo::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_RequestAllRoomInfo::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_RequestAllRoomInfo::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_RequestAllRoomInfo.result)
  return _internal_result();
}
inline void S_RequestAllRoomInfo::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_RequestAllRoomInfo::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_RequestAllRoomInfo.result)
}

// repeated .Protocol.RoomInfo roomList = 2;
inline int S_RequestAllRoomInfo::_internal_roomlist_size() const {
  return roomlist_.size();
}
inline int S_RequestAllRoomInfo::roomlist_size() const {
  return _internal_roomlist_size();
}
inline ::Protocol::RoomInfo* S_RequestAllRoomInfo::mutable_roomlist(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_RequestAllRoomInfo.roomList)
  return roomlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
S_RequestAllRoomInfo::mutable_roomlist() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_RequestAllRoomInfo.roomList)
  return &roomlist_;
}
inline const ::Protocol::RoomInfo& S_RequestAllRoomInfo::_internal_roomlist(int index) const {
  return roomlist_.Get(index);
}
inline const ::Protocol::RoomInfo& S_RequestAllRoomInfo::roomlist(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_RequestAllRoomInfo.roomList)
  return _internal_roomlist(index);
}
inline ::Protocol::RoomInfo* S_RequestAllRoomInfo::_internal_add_roomlist() {
  return roomlist_.Add();
}
inline ::Protocol::RoomInfo* S_RequestAllRoomInfo::add_roomlist() {
  // @@protoc_insertion_point(field_add:Protocol.S_RequestAllRoomInfo.roomList)
  return _internal_add_roomlist();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
S_RequestAllRoomInfo::roomlist() const {
  // @@protoc_insertion_point(field_list:Protocol.S_RequestAllRoomInfo.roomList)
  return roomlist_;
}

// -------------------------------------------------------------------

// C_WaitingRoomOut

// -------------------------------------------------------------------

// S_WaitingRoomOut

// .Protocol.EResultCode result = 1;
inline void S_WaitingRoomOut::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_WaitingRoomOut::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_WaitingRoomOut::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_WaitingRoomOut.result)
  return _internal_result();
}
inline void S_WaitingRoomOut::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_WaitingRoomOut::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_WaitingRoomOut.result)
}

// -------------------------------------------------------------------

// S_WaitingRoomOutNotify

// .Protocol.ObjectInfo player = 1;
inline bool S_WaitingRoomOutNotify::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool S_WaitingRoomOutNotify::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& S_WaitingRoomOutNotify::_internal_player() const {
  const ::Protocol::ObjectInfo* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_WaitingRoomOutNotify::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_WaitingRoomOutNotify.player)
  return _internal_player();
}
inline void S_WaitingRoomOutNotify::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_WaitingRoomOutNotify.player)
}
inline ::Protocol::ObjectInfo* S_WaitingRoomOutNotify::release_player() {
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_WaitingRoomOutNotify::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_WaitingRoomOutNotify.player)
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_WaitingRoomOutNotify::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::Protocol::ObjectInfo* S_WaitingRoomOutNotify::mutable_player() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_WaitingRoomOutNotify.player)
  return _internal_mutable_player();
}
inline void S_WaitingRoomOutNotify::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_WaitingRoomOutNotify.player)
}

// -------------------------------------------------------------------

// C_ChangeWaitingState

// .Protocol.EWaitingState state = 1;
inline void C_ChangeWaitingState::clear_state() {
  state_ = 0;
}
inline ::Protocol::EWaitingState C_ChangeWaitingState::_internal_state() const {
  return static_cast< ::Protocol::EWaitingState >(state_);
}
inline ::Protocol::EWaitingState C_ChangeWaitingState::state() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ChangeWaitingState.state)
  return _internal_state();
}
inline void C_ChangeWaitingState::_internal_set_state(::Protocol::EWaitingState value) {
  
  state_ = value;
}
inline void C_ChangeWaitingState::set_state(::Protocol::EWaitingState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ChangeWaitingState.state)
}

// -------------------------------------------------------------------

// S_ChangeWaitingState

// .Protocol.EResultCode result = 1;
inline void S_ChangeWaitingState::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_ChangeWaitingState::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_ChangeWaitingState::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeWaitingState.result)
  return _internal_result();
}
inline void S_ChangeWaitingState::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_ChangeWaitingState::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeWaitingState.result)
}

// .Protocol.EWaitingState state = 2;
inline void S_ChangeWaitingState::clear_state() {
  state_ = 0;
}
inline ::Protocol::EWaitingState S_ChangeWaitingState::_internal_state() const {
  return static_cast< ::Protocol::EWaitingState >(state_);
}
inline ::Protocol::EWaitingState S_ChangeWaitingState::state() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeWaitingState.state)
  return _internal_state();
}
inline void S_ChangeWaitingState::_internal_set_state(::Protocol::EWaitingState value) {
  
  state_ = value;
}
inline void S_ChangeWaitingState::set_state(::Protocol::EWaitingState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeWaitingState.state)
}

// -------------------------------------------------------------------

// S_ChangeWaitingStateNotify

// .Protocol.ObjectInfo player = 1;
inline bool S_ChangeWaitingStateNotify::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool S_ChangeWaitingStateNotify::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& S_ChangeWaitingStateNotify::_internal_player() const {
  const ::Protocol::ObjectInfo* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_ChangeWaitingStateNotify::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeWaitingStateNotify.player)
  return _internal_player();
}
inline void S_ChangeWaitingStateNotify::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ChangeWaitingStateNotify.player)
}
inline ::Protocol::ObjectInfo* S_ChangeWaitingStateNotify::release_player() {
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_ChangeWaitingStateNotify::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_ChangeWaitingStateNotify.player)
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_ChangeWaitingStateNotify::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::Protocol::ObjectInfo* S_ChangeWaitingStateNotify::mutable_player() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ChangeWaitingStateNotify.player)
  return _internal_mutable_player();
}
inline void S_ChangeWaitingStateNotify::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ChangeWaitingStateNotify.player)
}

// .Protocol.EWaitingState state = 2;
inline void S_ChangeWaitingStateNotify::clear_state() {
  state_ = 0;
}
inline ::Protocol::EWaitingState S_ChangeWaitingStateNotify::_internal_state() const {
  return static_cast< ::Protocol::EWaitingState >(state_);
}
inline ::Protocol::EWaitingState S_ChangeWaitingStateNotify::state() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeWaitingStateNotify.state)
  return _internal_state();
}
inline void S_ChangeWaitingStateNotify::_internal_set_state(::Protocol::EWaitingState value) {
  
  state_ = value;
}
inline void S_ChangeWaitingStateNotify::set_state(::Protocol::EWaitingState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeWaitingStateNotify.state)
}

// -------------------------------------------------------------------

// C_EnterGame

// -------------------------------------------------------------------

// S_EnterGame

// .Protocol.EResultCode result = 1;
inline void S_EnterGame::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_EnterGame::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_EnterGame::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterGame.result)
  return _internal_result();
}
inline void S_EnterGame::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_EnterGame::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EnterGame.result)
}

// .Protocol.ObjectInfo player = 2;
inline bool S_EnterGame::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool S_EnterGame::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& S_EnterGame::_internal_player() const {
  const ::Protocol::ObjectInfo* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_EnterGame::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterGame.player)
  return _internal_player();
}
inline void S_EnterGame::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_EnterGame.player)
}
inline ::Protocol::ObjectInfo* S_EnterGame::release_player() {
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_EnterGame::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_EnterGame.player)
  
  ::Protocol::ObjectInfo* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_EnterGame::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::Protocol::ObjectInfo* S_EnterGame::mutable_player() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_EnterGame.player)
  return _internal_mutable_player();
}
inline void S_EnterGame::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_EnterGame.player)
}

// -------------------------------------------------------------------

// C_EnterGameFinish

// -------------------------------------------------------------------

// S_EnterGameFinish

// .Protocol.EResultCode result = 1;
inline void S_EnterGameFinish::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_EnterGameFinish::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_EnterGameFinish::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterGameFinish.result)
  return _internal_result();
}
inline void S_EnterGameFinish::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_EnterGameFinish::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EnterGameFinish.result)
}

// -------------------------------------------------------------------

// C_LeaveGame

// -------------------------------------------------------------------

// S_LeaveGame

// -------------------------------------------------------------------

// C_Move

// .Protocol.ObjectInfo objectInfo = 1;
inline bool C_Move::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool C_Move::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& C_Move::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_Move::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Move.objectInfo)
  return _internal_objectinfo();
}
inline void C_Move::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_Move.objectInfo)
}
inline ::Protocol::ObjectInfo* C_Move::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* C_Move::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_Move.objectInfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_Move::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* C_Move::mutable_objectinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_Move.objectInfo)
  return _internal_mutable_objectinfo();
}
inline void C_Move::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Move.objectInfo)
}

// -------------------------------------------------------------------

// S_Move

// .Protocol.EResultCode result = 1;
inline void S_Move::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_Move::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_Move::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Move.result)
  return _internal_result();
}
inline void S_Move::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_Move::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Move.result)
}

// .Protocol.ObjectInfo objectInfo = 2;
inline bool S_Move::_internal_has_objectinfo() const {
  return this != internal_default_instance() && objectinfo_ != nullptr;
}
inline bool S_Move::has_objectinfo() const {
  return _internal_has_objectinfo();
}
inline const ::Protocol::ObjectInfo& S_Move::_internal_objectinfo() const {
  const ::Protocol::ObjectInfo* p = objectinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_Move::objectinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Move.objectInfo)
  return _internal_objectinfo();
}
inline void S_Move::unsafe_arena_set_allocated_objectinfo(
    ::Protocol::ObjectInfo* objectinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  objectinfo_ = objectinfo;
  if (objectinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_Move.objectInfo)
}
inline ::Protocol::ObjectInfo* S_Move::release_objectinfo() {
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Protocol::ObjectInfo* S_Move::unsafe_arena_release_objectinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_Move.objectInfo)
  
  ::Protocol::ObjectInfo* temp = objectinfo_;
  objectinfo_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_Move::_internal_mutable_objectinfo() {
  
  if (objectinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    objectinfo_ = p;
  }
  return objectinfo_;
}
inline ::Protocol::ObjectInfo* S_Move::mutable_objectinfo() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Move.objectInfo)
  return _internal_mutable_objectinfo();
}
inline void S_Move::set_allocated_objectinfo(::Protocol::ObjectInfo* objectinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo_);
  }
  if (objectinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(objectinfo));
    if (message_arena != submessage_arena) {
      objectinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, objectinfo, submessage_arena);
    }
    
  } else {
    
  }
  objectinfo_ = objectinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Move.objectInfo)
}

// -------------------------------------------------------------------

// S_Spawn

// .Protocol.EResultCode result = 1;
inline void S_Spawn::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_Spawn::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_Spawn::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Spawn.result)
  return _internal_result();
}
inline void S_Spawn::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_Spawn::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Spawn.result)
}

// repeated .Protocol.ObjectInfo objectList = 2;
inline int S_Spawn::_internal_objectlist_size() const {
  return objectlist_.size();
}
inline int S_Spawn::objectlist_size() const {
  return _internal_objectlist_size();
}
inline ::Protocol::ObjectInfo* S_Spawn::mutable_objectlist(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Spawn.objectList)
  return objectlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_Spawn::mutable_objectlist() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_Spawn.objectList)
  return &objectlist_;
}
inline const ::Protocol::ObjectInfo& S_Spawn::_internal_objectlist(int index) const {
  return objectlist_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_Spawn::objectlist(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_Spawn.objectList)
  return _internal_objectlist(index);
}
inline ::Protocol::ObjectInfo* S_Spawn::_internal_add_objectlist() {
  return objectlist_.Add();
}
inline ::Protocol::ObjectInfo* S_Spawn::add_objectlist() {
  // @@protoc_insertion_point(field_add:Protocol.S_Spawn.objectList)
  return _internal_add_objectlist();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_Spawn::objectlist() const {
  // @@protoc_insertion_point(field_list:Protocol.S_Spawn.objectList)
  return objectlist_;
}

// -------------------------------------------------------------------

// S_DeSpawn

// repeated uint64 ids = 1;
inline int S_DeSpawn::_internal_ids_size() const {
  return ids_.size();
}
inline int S_DeSpawn::ids_size() const {
  return _internal_ids_size();
}
inline void S_DeSpawn::clear_ids() {
  ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_DeSpawn::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_DeSpawn::ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_DeSpawn.ids)
  return _internal_ids(index);
}
inline void S_DeSpawn::set_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_DeSpawn.ids)
}
inline void S_DeSpawn::_internal_add_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  ids_.Add(value);
}
inline void S_DeSpawn::add_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_DeSpawn.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
S_DeSpawn::_internal_ids() const {
  return ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
S_DeSpawn::ids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_DeSpawn.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
S_DeSpawn::_internal_mutable_ids() {
  return &ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
S_DeSpawn::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_DeSpawn.ids)
  return _internal_mutable_ids();
}

// -------------------------------------------------------------------

// C_Chat

// string msg = 1;
inline void C_Chat::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& C_Chat::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_Chat.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_Chat::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_Chat.msg)
}
inline std::string* C_Chat::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_Chat.msg)
  return _internal_mutable_msg();
}
inline const std::string& C_Chat::_internal_msg() const {
  return msg_.Get();
}
inline void C_Chat::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_Chat::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_Chat::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.C_Chat.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_Chat::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_Chat.msg)
}

// -------------------------------------------------------------------

// S_Chat

// uint64 playerId = 1;
inline void S_Chat::clear_playerid() {
  playerid_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_Chat::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_Chat::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Chat.playerId)
  return _internal_playerid();
}
inline void S_Chat::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  playerid_ = value;
}
inline void S_Chat::set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_Chat.playerId)
}

// string msg = 2;
inline void S_Chat::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& S_Chat::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_Chat.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_Chat::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_Chat.msg)
}
inline std::string* S_Chat::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_Chat.msg)
  return _internal_mutable_msg();
}
inline const std::string& S_Chat::_internal_msg() const {
  return msg_.Get();
}
inline void S_Chat::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* S_Chat::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* S_Chat::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.S_Chat.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void S_Chat::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_Chat.msg)
}

// -------------------------------------------------------------------

// C_AnimationEvent

// string animationType = 1;
inline void C_AnimationEvent::clear_animationtype() {
  animationtype_.ClearToEmpty();
}
inline const std::string& C_AnimationEvent::animationtype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AnimationEvent.animationType)
  return _internal_animationtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_AnimationEvent::set_animationtype(ArgT0&& arg0, ArgT... args) {
 
 animationtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_AnimationEvent.animationType)
}
inline std::string* C_AnimationEvent::mutable_animationtype() {
  // @@protoc_insertion_point(field_mutable:Protocol.C_AnimationEvent.animationType)
  return _internal_mutable_animationtype();
}
inline const std::string& C_AnimationEvent::_internal_animationtype() const {
  return animationtype_.Get();
}
inline void C_AnimationEvent::_internal_set_animationtype(const std::string& value) {
  
  animationtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* C_AnimationEvent::_internal_mutable_animationtype() {
  
  return animationtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* C_AnimationEvent::release_animationtype() {
  // @@protoc_insertion_point(field_release:Protocol.C_AnimationEvent.animationType)
  return animationtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void C_AnimationEvent::set_allocated_animationtype(std::string* animationtype) {
  if (animationtype != nullptr) {
    
  } else {
    
  }
  animationtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), animationtype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_AnimationEvent.animationType)
}

// .Protocol.EAnimationParamType paramType = 2;
inline void C_AnimationEvent::clear_paramtype() {
  paramtype_ = 0;
}
inline ::Protocol::EAnimationParamType C_AnimationEvent::_internal_paramtype() const {
  return static_cast< ::Protocol::EAnimationParamType >(paramtype_);
}
inline ::Protocol::EAnimationParamType C_AnimationEvent::paramtype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AnimationEvent.paramType)
  return _internal_paramtype();
}
inline void C_AnimationEvent::_internal_set_paramtype(::Protocol::EAnimationParamType value) {
  
  paramtype_ = value;
}
inline void C_AnimationEvent::set_paramtype(::Protocol::EAnimationParamType value) {
  _internal_set_paramtype(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AnimationEvent.paramType)
}

// bool boolValue = 3;
inline void C_AnimationEvent::clear_boolvalue() {
  boolvalue_ = false;
}
inline bool C_AnimationEvent::_internal_boolvalue() const {
  return boolvalue_;
}
inline bool C_AnimationEvent::boolvalue() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AnimationEvent.boolValue)
  return _internal_boolvalue();
}
inline void C_AnimationEvent::_internal_set_boolvalue(bool value) {
  
  boolvalue_ = value;
}
inline void C_AnimationEvent::set_boolvalue(bool value) {
  _internal_set_boolvalue(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AnimationEvent.boolValue)
}

// float floatValue = 4;
inline void C_AnimationEvent::clear_floatvalue() {
  floatvalue_ = 0;
}
inline float C_AnimationEvent::_internal_floatvalue() const {
  return floatvalue_;
}
inline float C_AnimationEvent::floatvalue() const {
  // @@protoc_insertion_point(field_get:Protocol.C_AnimationEvent.floatValue)
  return _internal_floatvalue();
}
inline void C_AnimationEvent::_internal_set_floatvalue(float value) {
  
  floatvalue_ = value;
}
inline void C_AnimationEvent::set_floatvalue(float value) {
  _internal_set_floatvalue(value);
  // @@protoc_insertion_point(field_set:Protocol.C_AnimationEvent.floatValue)
}

// -------------------------------------------------------------------

// S_AnimationEvent

// .Protocol.EResultCode result = 1;
inline void S_AnimationEvent::clear_result() {
  result_ = 0;
}
inline ::Protocol::EResultCode S_AnimationEvent::_internal_result() const {
  return static_cast< ::Protocol::EResultCode >(result_);
}
inline ::Protocol::EResultCode S_AnimationEvent::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AnimationEvent.result)
  return _internal_result();
}
inline void S_AnimationEvent::_internal_set_result(::Protocol::EResultCode value) {
  
  result_ = value;
}
inline void S_AnimationEvent::set_result(::Protocol::EResultCode value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AnimationEvent.result)
}

// uint64 playerId = 2;
inline void S_AnimationEvent::clear_playerid() {
  playerid_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_AnimationEvent::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 S_AnimationEvent::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AnimationEvent.playerId)
  return _internal_playerid();
}
inline void S_AnimationEvent::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  playerid_ = value;
}
inline void S_AnimationEvent::set_playerid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AnimationEvent.playerId)
}

// string animationType = 3;
inline void S_AnimationEvent::clear_animationtype() {
  animationtype_.ClearToEmpty();
}
inline const std::string& S_AnimationEvent::animationtype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AnimationEvent.animationType)
  return _internal_animationtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_AnimationEvent::set_animationtype(ArgT0&& arg0, ArgT... args) {
 
 animationtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_AnimationEvent.animationType)
}
inline std::string* S_AnimationEvent::mutable_animationtype() {
  // @@protoc_insertion_point(field_mutable:Protocol.S_AnimationEvent.animationType)
  return _internal_mutable_animationtype();
}
inline const std::string& S_AnimationEvent::_internal_animationtype() const {
  return animationtype_.Get();
}
inline void S_AnimationEvent::_internal_set_animationtype(const std::string& value) {
  
  animationtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* S_AnimationEvent::_internal_mutable_animationtype() {
  
  return animationtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* S_AnimationEvent::release_animationtype() {
  // @@protoc_insertion_point(field_release:Protocol.S_AnimationEvent.animationType)
  return animationtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void S_AnimationEvent::set_allocated_animationtype(std::string* animationtype) {
  if (animationtype != nullptr) {
    
  } else {
    
  }
  animationtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), animationtype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_AnimationEvent.animationType)
}

// .Protocol.EAnimationParamType paramType = 4;
inline void S_AnimationEvent::clear_paramtype() {
  paramtype_ = 0;
}
inline ::Protocol::EAnimationParamType S_AnimationEvent::_internal_paramtype() const {
  return static_cast< ::Protocol::EAnimationParamType >(paramtype_);
}
inline ::Protocol::EAnimationParamType S_AnimationEvent::paramtype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AnimationEvent.paramType)
  return _internal_paramtype();
}
inline void S_AnimationEvent::_internal_set_paramtype(::Protocol::EAnimationParamType value) {
  
  paramtype_ = value;
}
inline void S_AnimationEvent::set_paramtype(::Protocol::EAnimationParamType value) {
  _internal_set_paramtype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AnimationEvent.paramType)
}

// bool boolValue = 5;
inline void S_AnimationEvent::clear_boolvalue() {
  boolvalue_ = false;
}
inline bool S_AnimationEvent::_internal_boolvalue() const {
  return boolvalue_;
}
inline bool S_AnimationEvent::boolvalue() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AnimationEvent.boolValue)
  return _internal_boolvalue();
}
inline void S_AnimationEvent::_internal_set_boolvalue(bool value) {
  
  boolvalue_ = value;
}
inline void S_AnimationEvent::set_boolvalue(bool value) {
  _internal_set_boolvalue(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AnimationEvent.boolValue)
}

// float floatValue = 6;
inline void S_AnimationEvent::clear_floatvalue() {
  floatvalue_ = 0;
}
inline float S_AnimationEvent::_internal_floatvalue() const {
  return floatvalue_;
}
inline float S_AnimationEvent::floatvalue() const {
  // @@protoc_insertion_point(field_get:Protocol.S_AnimationEvent.floatValue)
  return _internal_floatvalue();
}
inline void S_AnimationEvent::_internal_set_floatvalue(float value) {
  
  floatvalue_ = value;
}
inline void S_AnimationEvent::set_floatvalue(float value) {
  _internal_set_floatvalue(value);
  // @@protoc_insertion_point(field_set:Protocol.S_AnimationEvent.floatValue)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
